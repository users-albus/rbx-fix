import {
    BatchRequestError,
    DefaultProcessBatchWaitTime
} from './batchRequestConstants';
import {
    getFailureCooldown
} from './batchRequestUtil';
var BatchRequestProcessor = /** @class */ (function() {
    function BatchRequestProcessor() {
        this.completeItems = new Map();
        this.requestQueue = [];
        this.active = false;
    }
    BatchRequestProcessor.prototype.handleBatchResult = function(itemsProcessor, batch, error, properties) {
        var _this = this;
        var minimumCooldown = 0;
        var currentDate = new Date().getTime();
        batch.forEach(function(request) {
            if (_this.completeItems.has(request.key)) {
                request.resolve(_this.completeItems.get(request.key));
            } else if (properties.maxRetryAttempts &&
                properties.maxRetryAttempts > 0 &&
                error !== BatchRequestError.unretriableFailure) {
                var itemCooldown = getFailureCooldown(request.retryAttempts, properties);
                if (minimumCooldown > 0) {
                    minimumCooldown = Math.min(minimumCooldown, itemCooldown);
                } else {
                    minimumCooldown = itemCooldown;
                }
                if (request.retryAttempts + 1 <= properties.maxRetryAttempts) {
                    request.retryAttempts += 1;
                    request.queueAfter = currentDate + itemCooldown;
                    // Put in front of the queue to make sure duplicate items
                    // don't get processed without the cooldown time.
                    _this.requestQueue.unshift(request);
                } else {
                    request.reject(BatchRequestError.maxAttemptsReached);
                }
            } else {
                request.reject(error);
            }
        });
        var processBatchWaitTime = DefaultProcessBatchWaitTime;
        if (properties && properties.processBatchWaitTime) {
            processBatchWaitTime = properties.processBatchWaitTime;
        }
        if (minimumCooldown > 0) {
            setTimeout(function() {
                return _this.processQueue(itemsProcessor, properties);
            }, minimumCooldown + processBatchWaitTime);
        }
        this.active = false;
        this.processQueue(itemsProcessor, properties);
    };
    BatchRequestProcessor.prototype.processQueue = function(itemsProcessor, properties) {
        var _a;
        var _this = this;
        if (this.active) {
            return;
        }
        var batch = [];
        var batchKeys = new Map();
        var requeueRequests = [];
        var currentDate = new Date().getTime();
        while (batch.length < properties.batchSize && this.requestQueue.length > 0) {
            var request = this.requestQueue.shift();
            if (request) {
                if (request.queueAfter > currentDate) {
                    batchKeys.set(request.key, request);
                    requeueRequests.push(request);
                } else if (this.completeItems.has(request.key)) {
                    request.resolve(this.completeItems.get(request.key));
                } else if (batchKeys.has(request.key)) {
                    // Requeue to make sure duplicate requests still get resolved once they're completed.
                    requeueRequests.push(request);
                } else {
                    batchKeys.set(request.key, request);
                    batch.push(request);
                }
            }
        }
        (_a = this.requestQueue).push.apply(_a, requeueRequests);
        if (batch.length <= 0) {
            return;
        }
        this.active = true;
        itemsProcessor(batch).then(function(data) {
            Object.keys(data).forEach(function(key) {
                _this.saveCompleteItem(key, data[key], properties);
            });
            _this.handleBatchResult(itemsProcessor, batch, BatchRequestError.processFailure, properties);
        }, function(error) {
            _this.handleBatchResult(itemsProcessor, batch, error, properties);
        });
    };
    BatchRequestProcessor.prototype.saveCompleteItem = function(key, data, properties) {
        var _this = this;
        this.completeItems.set(key, data);
        if (properties.getItemExpiration) {
            setTimeout(function() {
                _this.completeItems.delete(key);
            }, properties.getItemExpiration(key));
        }
    };
    BatchRequestProcessor.prototype.queueItem = function(itemId, itemProcessor, itemSerializer, properties) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            _this.requestQueue.push({
                key: itemSerializer(itemId),
                itemId: itemId,
                retryAttempts: 0,
                queueAfter: 0,
                startTime: new Date(),
                resolve: resolve,
                reject: reject
            });
            setTimeout(function() {
                return _this.processQueue(itemProcessor, properties);
            }, properties.processBatchWaitTime);
        });
    };
    BatchRequestProcessor.prototype.invalidateItem = function(itemId, itemSerializer) {
        this.completeItems.delete(itemSerializer(itemId));
    };
    return BatchRequestProcessor;
}());
export default BatchRequestProcessor;